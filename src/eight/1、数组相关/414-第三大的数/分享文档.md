# 第三大的数
## **思路:** 维护3个值，分别代表最大，第二大，第三大的数
   1. 直接维护三个独立的值，自己进行重复比较和排序增减 
      * **空间:O(1)** 只需要1,2,3
      * **时间:O(n)** 全部数组遍历一遍
      * **排序** 
        * **初级** 新元素与维护元素**从大到小**进行比较,**不会出现嵌套**的情况,易于阅读
        * **剪枝** 新元素与维护元素**从小到大**进行比较,需要**嵌套比较**,因至少维护第三大的元素,所以**比较次数**会减少,运行速度块,**不易于阅读**
      * **去重** 
        * **基本思路** 每个**新元素**都与维护的数值进行相等比较,**在排序之前**进行
        * **简化思路** 每个**新元素**在**排序**时仅仅处理绝对大于/小于,不处理相等
   2. 使用数组维护，api排序，自己判断重复
      * **空间:O(1)** 只需要1,2,3
      * **时间:O(n)** 全部数组遍历一遍
      * **原生排序+手动去重** 用indexOf()去重,用sort((a,b)=>b-a)排序,写起来**简单**,时间复杂度略微欠佳
      * **和独立值一样的排序,去重方式** 
   3. 使用treeSet维护，自动排序并去重 ***js不支持***
      * **空间:O(n)** 全部元素需要添加到set
      * **时间:O(n)** 全部数组遍历一遍
      * **代替** js的set本身不支持排序,可能需要在set和array之间转换,无论时间复杂度还是空间复杂度都欠佳.