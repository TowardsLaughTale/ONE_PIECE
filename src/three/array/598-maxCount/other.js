// [
//     [0,0,0,0],
//     [0,0,0,0],
//     [0,0,0,0],
//     [0,0,0,0]
// ]

// [2,2]
// [
//     [1,1,0,0],
//     [1,1,0,0],
//     [0,0,0,0],
//     [0,0,0,0]
// ]

// [3,3]
// [
//     [2,2,1,0],
//     [2,2,1,0],
//     [1,1,1,0],
//     [0,0,0,0]
// ]

// [3,4]
// [
//     [3,3,2,0],
//     [3,3,2,0],
//     [2,2,2,0],
//     [1,1,1,0]
// ]

// 思路：
// 每个操作是在 x 为 op[0], y 为 op[1] 的网格中做元素的 +1 操作
// 那么最大的那部分，应该是各个操作的交集部分

// 所有取各个操作 x 和 y 轴上的最小值，进行相乘，即是结果

// 执行用时：76 ms, 在所有 JavaScript 提交中击败了92.63%的用户
// 内存消耗：38.3 MB, 在所有 JavaScript 提交中击败了76.56%的用户
let maxCount = function (m, n, ops) {
    ops.forEach(op => {
        m = Math.min(m, op[0])
        n = Math.min(n, op[1])
    })
    return m * n
}
let n = m = 39999
39999
let ops = [[19999,19999]]
// let m = 3, n = 3
// ops = [[2,2],[3,3]]
let r = maxCount(m, n, ops)
console.log('r :>> ', r)